/* Generated by re2c 2.2 on Tue Oct 12 17:32:32 2021 */
#line 1 "preprocessor.re"
#include <iostream>
#include <map>

#include <lfortran/parser/preprocessor.h>
#include <lfortran/assert.h>
#include <lfortran/utils.h>
#include <lfortran/string_utils.h>

namespace LFortran
{

std::string CPreprocessor::token(unsigned char *tok, unsigned char* cur) const
{
    return std::string((char *)tok, cur - tok);
}

void parse_macro_definition(const std::string &line,
    std::string &name, std::string &subs)
{
    size_t i = 0;
    i += std::string("#define").size();
    while (line[i] == ' ') i++;
    size_t s1 = i;
    while (line[i] != ' ') i++;
    name = std::string(&line[s1], i-s1);
    while (line[i] == ' ') i++;
    subs = line.substr(i, line.size()-i-1);
}

void parse_include_line(const std::string &line, std::string &filename)
{
    size_t i = 0;
    i += std::string("#include").size();
    while (line[i] != '"') i++;
    i++;
    size_t s1 = i;
    while (line[i] != '"') i++;
    filename = std::string(&line[s1], i-s1);
}

void get_newlines(const std::string &s, std::vector<uint32_t> &newlines) {
    for (uint32_t pos=0; pos < s.size(); pos++) {
        if (s[pos] == '\n') newlines.push_back(pos);
    }
}

std::string CPreprocessor::run(const std::string &input, LocationManager &lm,
        std::map<std::string, std::string> &macro_definitions) const {
    LFORTRAN_ASSERT(input[input.size()] == '\0');
    unsigned char *string_start=(unsigned char*)(&input[0]);
    unsigned char *cur = string_start;
    Location loc;
    std::string output;
    lm.preprocessor = true;
    get_newlines(input, lm.in_newlines0);
    lm.out_start0.push_back(0);
    lm.in_start0.push_back(0);
    for (;;) {
        unsigned char *tok = cur;
        unsigned char *mar;
        
#line 65 "preprocessor.cpp"
{
	unsigned char yych;
	unsigned int yyaccept = 0;
	static const unsigned char yybm[] = {
		  0, 176, 176, 176, 176, 176, 176, 176, 
		176, 240,  48, 240, 176, 240, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		240, 176, 160, 176, 176, 176, 176, 144, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		184, 184, 184, 184, 184, 184, 184, 184, 
		184, 184, 176, 176, 176, 176, 176, 176, 
		176, 184, 184, 184, 184, 184, 184, 184, 
		184, 184, 184, 184, 184, 184, 184, 184, 
		184, 184, 184, 184, 184, 184, 184, 184, 
		184, 184, 184, 176, 176, 176, 176, 184, 
		176, 184, 184, 184, 184, 184, 184, 184, 
		184, 184, 184, 184, 184, 184, 184, 184, 
		184, 184, 184, 184, 184, 184, 184, 184, 
		184, 184, 184, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
		176, 176, 176, 176, 176, 176, 176, 176, 
	};
	yych = *cur;
	if (yych <= '\'') {
		if (yych <= '"') {
			if (yych <= 0x00) goto yy2;
			if (yych <= '!') goto yy4;
			goto yy6;
		} else {
			if (yych <= '#') goto yy7;
			if (yych <= '&') goto yy4;
			goto yy8;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '@') goto yy4;
			if (yych <= 'Z') goto yy9;
			goto yy4;
		} else {
			if (yych == '`') goto yy4;
			if (yych <= 'z') goto yy9;
			goto yy4;
		}
	}
yy2:
	++cur;
#line 81 "preprocessor.re"
	{
                break;
            }
#line 131 "preprocessor.cpp"
yy4:
	++cur;
yy5:
#line 76 "preprocessor.re"
	{
                token_loc(loc, tok, cur, string_start);
                output.append(token(tok, cur));
                continue;
            }
#line 141 "preprocessor.cpp"
yy6:
	yyaccept = 0;
	yych = *(mar = ++cur);
	if (yych <= 0x00) goto yy5;
	goto yy13;
yy7:
	yyaccept = 0;
	yych = *(mar = ++cur);
	if (yych == 'd') goto yy17;
	if (yych == 'i') goto yy18;
	goto yy5;
yy8:
	yyaccept = 0;
	yych = *(mar = ++cur);
	if (yych <= 0x00) goto yy5;
	goto yy20;
yy9:
	yych = *++cur;
	if (yybm[0+yych] & 8) {
		goto yy9;
	}
#line 137 "preprocessor.re"
	{
                std::string t = token(tok, cur);
                if (macro_definitions.find(t) != macro_definitions.end()) {
                    // Prepare the start of the interval
                    lm.out_start0.push_back(output.size());
                    lm.in_start0.push_back(tok-string_start);
                    // The just created interval ID:
                    size_t N = lm.out_start0.size()-2;
                    lm.in_size0.push_back(lm.out_start0[N+1]-lm.out_start0[N]);
                    lm.interval_type0.push_back(0);

                    // Expand the macro recursively
                    std::string expansion = macro_definitions[t];
                    std::string expansion2;
                    int i = 0;
                    while (expansion2 != expansion) {
                        expansion2 = expansion;
                        LocationManager lm_tmp = lm; // Make a copy
                        expansion = run(expansion2, lm_tmp, macro_definitions);
                        i++;
                        if (i == 40) {
                            throw LFortranException("C preprocessor: maximum recursion limit reached");
                        }
                    }
                    output.append(expansion);

                    // Prepare the end of the interval
                    lm.out_start0.push_back(output.size());
                    lm.in_start0.push_back(cur-string_start);
                    // The just created interval ID:
                    N = lm.out_start0.size()-2;
                    lm.in_size0.push_back(t.size());
                    lm.interval_type0.push_back(1);
                } else {
                    output.append(t);
                }
                continue;
            }
#line 202 "preprocessor.cpp"
yy12:
	yych = *++cur;
yy13:
	if (yybm[0+yych] & 16) {
		goto yy12;
	}
	if (yych >= 0x01) goto yy15;
yy14:
	cur = mar;
	if (yyaccept <= 1) {
		if (yyaccept == 0) {
			goto yy5;
		} else {
			goto yy16;
		}
	} else {
		goto yy22;
	}
yy15:
	yyaccept = 1;
	yych = *(mar = ++cur);
	if (yych == '"') goto yy12;
yy16:
#line 175 "preprocessor.re"
	{
                output.append(token(tok, cur));
                continue;
            }
#line 231 "preprocessor.cpp"
yy17:
	yych = *++cur;
	if (yych == 'e') goto yy23;
	goto yy14;
yy18:
	yych = *++cur;
	if (yych == 'n') goto yy24;
	goto yy14;
yy19:
	yych = *++cur;
yy20:
	if (yybm[0+yych] & 32) {
		goto yy19;
	}
	if (yych <= 0x00) goto yy14;
	yyaccept = 2;
	yych = *(mar = ++cur);
	if (yych == '\'') goto yy19;
yy22:
#line 179 "preprocessor.re"
	{
                output.append(token(tok, cur));
                continue;
            }
#line 256 "preprocessor.cpp"
yy23:
	yych = *++cur;
	if (yych == 'f') goto yy25;
	goto yy14;
yy24:
	yych = *++cur;
	if (yych == 'c') goto yy26;
	goto yy14;
yy25:
	yych = *++cur;
	if (yych == 'i') goto yy27;
	goto yy14;
yy26:
	yych = *++cur;
	if (yych == 'l') goto yy28;
	goto yy14;
yy27:
	yych = *++cur;
	if (yych == 'n') goto yy29;
	goto yy14;
yy28:
	yych = *++cur;
	if (yych == 'u') goto yy30;
	goto yy14;
yy29:
	yych = *++cur;
	if (yych == 'e') goto yy31;
	goto yy14;
yy30:
	yych = *++cur;
	if (yych == 'd') goto yy32;
	goto yy14;
yy31:
	yych = *++cur;
	if (yych <= '^') {
		if (yych <= '@') goto yy34;
		if (yych <= 'Z') goto yy14;
		goto yy34;
	} else {
		if (yych == '`') goto yy34;
		if (yych <= 'z') goto yy14;
		goto yy34;
	}
yy32:
	yych = *++cur;
	if (yych == 'e') goto yy35;
	goto yy14;
yy33:
	yych = *++cur;
yy34:
	if (yybm[0+yych] & 64) {
		goto yy33;
	}
	if (yych <= '^') {
		if (yych <= '@') goto yy14;
		if (yych <= 'Z') goto yy36;
		goto yy14;
	} else {
		if (yych == '`') goto yy14;
		if (yych <= 'z') goto yy36;
		goto yy14;
	}
yy35:
	yych = *++cur;
	if (yych == '"') goto yy14;
	goto yy39;
yy36:
	yych = *++cur;
	if (yych <= ' ') {
		if (yych <= '\v') {
			if (yych == '\t') goto yy40;
			if (yych <= '\n') goto yy14;
			goto yy40;
		} else {
			if (yych == '\r') goto yy40;
			if (yych <= 0x1F) goto yy14;
			goto yy40;
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '/') goto yy14;
			if (yych <= '9') goto yy36;
			if (yych <= '@') goto yy14;
			goto yy36;
		} else {
			if (yych <= '_') {
				if (yych <= '^') goto yy14;
				goto yy36;
			} else {
				if (yych <= '`') goto yy14;
				if (yych <= 'z') goto yy36;
				goto yy14;
			}
		}
	}
yy38:
	yych = *++cur;
yy39:
	switch (yych) {
	case '\t':
	case '\v':
	case '\r':
	case ' ':	goto yy38;
	case '"':	goto yy42;
	default:	goto yy14;
	}
yy40:
	yych = *++cur;
	if (yybm[0+yych] & 128) {
		goto yy40;
	}
	if (yych <= 0x00) goto yy14;
	goto yy44;
yy42:
	yych = *++cur;
	if (yych <= 0x00) goto yy14;
	if (yych == '"') goto yy46;
	goto yy42;
yy44:
	++cur;
#line 84 "preprocessor.re"
	{
                std::string macro_name, macro_subs;
                parse_macro_definition(token(tok, cur),
                    macro_name, macro_subs);
                macro_definitions[macro_name] = macro_subs;
                lm.out_start0.push_back(output.size());
                lm.in_start0.push_back(cur-string_start);
                // The just created interval ID:
                size_t N = lm.out_start0.size()-2;
                lm.in_size0.push_back(lm.out_start0[N+1]-lm.out_start0[N]);
                lm.interval_type0.push_back(0);
                continue;
            }
#line 391 "preprocessor.cpp"
yy46:
	yych = *++cur;
	if (yych <= 0x00) goto yy14;
	if (yych != '\n') goto yy46;
	++cur;
#line 97 "preprocessor.re"
	{
                std::string line = token(tok, cur);
                std::string include;
                std::string filename;
                parse_include_line(line, filename);
                // Construct a filename relative to the current file
                // TODO: make this multiplatform
                std::string base_dir = lm.in_filename;
                std::string::size_type n = base_dir.rfind("/");
                if (n != std::string::npos) {
                    base_dir = base_dir.substr(0, n);
                    filename = base_dir + "/" + filename;
                }
                if (!read_file(filename, include)) {
                    throw LFortranException("C preprocessor: include file '" + filename + "' cannot be opened");
                }

                LocationManager lm_tmp = lm; // Make a copy
                include = run(include, lm_tmp, macro_definitions);

                // Prepare the start of the interval
                lm.out_start0.push_back(output.size());
                lm.in_start0.push_back(tok-string_start);
                // The just created interval ID:
                size_t N = lm.out_start0.size()-2;
                lm.in_size0.push_back(lm.out_start0[N+1]-lm.out_start0[N]);
                lm.interval_type0.push_back(0);

                // Include
                output.append(include);

                // Prepare the end of the interval
                lm.out_start0.push_back(output.size());
                lm.in_start0.push_back(cur-string_start);
                // The just created interval ID:
                N = lm.out_start0.size()-2;
                lm.in_size0.push_back(token(tok, cur).size()-1);
                lm.interval_type0.push_back(1);
                continue;
            }
#line 438 "preprocessor.cpp"
}
#line 183 "preprocessor.re"

    }
    lm.out_start0.push_back(output.size());
    lm.in_start0.push_back(input.size());
    // The just created interval ID:
    size_t N = lm.out_start0.size()-2;
    lm.in_size0.push_back(lm.out_start0[N+1]-lm.out_start0[N]);
    lm.interval_type0.push_back(0);

    // Uncomment for debugging
    /*
    std::cout << "in_start0: ";
    for (auto A : lm.in_start0) { std::cout << A << " "; }
    std::cout << std::endl;
    std::cout << "in_size0: ";
    for (auto A : lm.in_size0) { std::cout << A << " "; }
    std::cout << std::endl;
    std::cout << "interval_type0: ";
    for (auto A : lm.interval_type0) { std::cout << A << " "; }
    std::cout << std::endl;
    std::cout << "out_start0: ";
    for (auto A : lm.out_start0) { std::cout << A << " "; }
    std::cout << std::endl;
    */

    return output;
}

} // namespace LFortran
